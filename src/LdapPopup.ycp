/**
 * File:	modules/LdapPopup.ycp
 * Package:	Configuration of LDAP
 * Summary:	Additional user interface functions: special edit popups
 * Authors:	Jiri Suchomel <jsuchome@suse.cz>
 *
 * $Id$
 *
 * Popups for editing the values of LDAP configuration tables.
 */

{

module "LdapPopup";
textdomain "ldap-client";

import "Ldap";
import "Label";
import "Popup";
import "Wizard";

    /**
     * Popup for browsing LDAP tree and selecting the DN
     * WARNING we expect that LDAP connection is already correctly initialized !
     * @param root_dn the starting point (root of tree); if empty string is
     * given, the search for available bases will be done automatically
     * @return DN of selected item, empty string when canceled
     */
    global define string BrowseTree (string root_dn) {

	// get display mode
	map display_info = UI::GetDisplayInfo();
	boolean textmode = display_info["TextMode"]:true;

	// map of already read subtrees
	map<string,boolean> dns	= $[];
	// selected DN (return value)
	string current_dn	= "";

	term contents = `HBox (`VSpacing (20), `VBox (`HSpacing(70),
	    `VSpacing (0.2),
	    `HBox (
		`HSpacing (),
		`ReplacePoint (`id (`reptree), `Tree (`id(`tree), root_dn, [])),
		`ReplacePoint (`id (`repbuttons), `Empty ()),
		`HSpacing ()
	    ),
	    `HBox (
		`HSpacing (1.5),
	        `PushButton (`id (`ok), `opt (`key_F10), Label::OKButton()),
		`PushButton(`id (`cancel),`opt (`key_F9),Label::CancelButton()),
		// pushbutton label
		textmode ?
		  // button label
		  `Right (`PushButton (`id (`open), `opt (`key_F6),_("&Open"))):
		  `Empty (),
		`HSpacing (1.5)
	    ),
	    `VSpacing (0.2)
	));

	UI::OpenDialog (`opt (`decorated), contents);

	list<term> items	= [];
	list<string> out	= (list<string>) SCR::Read (.ldap.search, $[
		"base_dn"	: root_dn,
		"scope"		: 1,
		"dn_only"	: true,
		"not_found_ok"	: true ]
	);
	if (size (out) > 0)
	{
	    items = maplist (string dn, out, {
		dns [dn]	= false;
		return `item (dn, false, []);
	    });
	}

	if (size (items) > 0)
	{
	    UI::ReplaceWidget (`id (`reptree), textmode ?
		`Tree (`id(`tree), root_dn, items) :
		`Tree (`id(`tree), `opt(`notify), root_dn, items));
	}
	else if (root_dn == "")
	{
	    list bases = (list) SCR::Read (.ldap.search, $[
		"base_dn"	: "",
	        "scope"		: 0,
		"attrs"		: [ "namingcontexts" ]
	    ]);
	    if (size (bases) > 0)
		items = maplist (string dn, bases[0,"namingcontexts"]:[],
		    ``(`item(dn, false, [])));
	    if (size (items) > 0)
		UI::ReplaceWidget (`id (`reptree), textmode ?
		    `Tree (`id(`tree), root_dn, items) :
		    `Tree (`id(`tree), `opt(`notify), root_dn, items));
	}

	if (textmode)
	    UI::SetFocus (`id(`tree));

	list<string> subdns	= [];
	map open_items		= $[];

	define list<term> update_items (list<term> its) {

	    return maplist (term it, its, {
		string dn	= it[0]:"";
		if (dn == current_dn)
		{
		    return `item (dn, true, maplist (string k,
			subdns, ``(`item (k, false, []))));
		}
		integer last = size (it) - 1;
		if (size (it[last]:[]) == 0)
		    return it;
		// `OpenItems doesn't work in ncurses...
		boolean open = haskey (open_items, dn) && !textmode;
		return `item (dn, open, update_items (it[last]:[]));
	    });
	}

	string retval = root_dn;
	while (true)
	{
	    any ret = UI::UserInput ();
	    if (ret == `tree || ret == `open)
	    {
		current_dn = (string) UI::QueryWidget (`id(`tree),`CurrentItem);
		if (! dns[current_dn]:false)
		{
		    subdns = (list<string>) SCR::Read (.ldap.search, $[
			"base_dn"	: current_dn,
			"scope"		: 1,
			"dn_only"	: true,
			"not_found_ok"	: true,
		    ]);
		    dns [current_dn]	= true;
		    if (size (subdns) > 0)
		    {
			open_items = (map) UI::QueryWidget (`tree, `OpenItems);
			items	= update_items (items);
			UI::ReplaceWidget (`id (`reptree), textmode ?
			    `Tree (`id(`tree), root_dn, items) :
			    `Tree (`id(`tree), `opt(`notify), root_dn, items));
			UI::ChangeWidget (`id(`tree), `CurrentItem, current_dn);
			open_items = $[];
		    }
		}
		if (textmode)
		    UI::SetFocus (`id(`tree));
	    }
	    if (ret == `cancel)
	    {
		retval = "";
		break;
	    }
	    if (ret == `ok)
	    {
		string dn = (string)UI::QueryWidget (`id(`tree), `CurrentItem);
		if (dn != nil)
		    retval = dn;
		else retval = current_dn;
		break;
	    }
	}
	UI::CloseDialog ();
	return retval;
    }

    /**
     * Open the LDAP Browse popup and initialize initialize LDAP connection
     * before.
     * @param connection init map with information passed to ldap agent
     * (see ldap agent '.ldap' Execute call documentation)
     * @param root_dn the starting point (root of tree); if empty string is
     * given, the search for available bases will be done automatically
     * @return DN of selected item, empty string when canceled
     */
    global define string InitAndBrowseTree (string root_dn, map connection) {

	map args = size (connection) > 0 ? connection : $[
	    "hostname"	: Ldap::GetFirstServer (Ldap::server),
	    "port"	: Ldap::GetFirstPort (Ldap::server),
	    "version"	: Ldap::ldap_v2 ? 2 : 3,
	    "use_tls"	: Ldap::ldap_tls ? "yes" : "no"
	];
	boolean init = (boolean) SCR::Execute (.ldap, args);
	if (init == nil || !init)
	{
	    Ldap::LDAPErrorMessage ("init", Ldap::LDAPError ());
	    return root_dn;
	}
	return BrowseTree (root_dn);
    }


/**
 * Generic popup for editing attribute's value
 * @param map with settings, it could have these keys:
 *  "attr"	attribute name
 *  "value"	current attribute values
 *  "conflicts" list of forbidden values (e.g. existing 'cn' values)
 *  "single"	if attribute can have only one value
 *  "offer"	list of possible values for current attribute (e.g. existing
 *		groups for "secondaryGroup" attribute)
 *  "browse"	if Browse LDAP Tree widget should be provided for choosing DN
 * @return list of atrtibute values (edited or unchanged)
 */
global define list<string> EditAttribute (map settings)
{

    string attr		= settings["attr"]:"";
    list<string> value	= settings["value"]:[];
    list conflicts	= settings["conflicts"]:[];
    list offer		= settings["offer"]:[];
    boolean single	= settings["single"]:false;
    boolean browse	= settings["browse"]:false;

    // help text 1/3
    string help_text = _("<p>Set the new value for the current attribute.</p>") +

    // help text 2/3
    _("<p>If the attribute can have more values, add new entries
with <b>Add Value</b>. Sometimes the button contains the list of
possible values to use for the current attribute.
If the value of the edited attribute should be a distinguished name (DN),
it is possible to choose it from LDAP tree using <b>Browse</b>.
</p>
");

    string desc = Ldap::AttributeDescription (attr);

    if (desc != "")
	// help text 3/3, %1 is attribute name, description follows.
	// The description will be not translated: maybe add a note
	// "available only in english" to the sentence for other languages?
	// Example:
	// "<p>The description of attribute \"%1\"<br>(available only in english):</p>"
	// or:
	// "<p>The description (only in english) of attribute \"%1\":<br></p>"
	help_text = help_text + sformat (_("<p>The description of attribute \"%1\":<br></p>"), attr) +

	sformat ("<p><i>%1</i></p>", desc);

    list<string> org_value = value;
    integer value_size = size (value);

    // horizontal size of popup for
    integer hsize = size (value[0]:"") + 10;

    /**
     * Helper for creating items for EditAttribute Popup
     */
    define term generate_value_list () ``{
	term ret = `VBox();
	if (single)
	{
	    ret = add (ret, `TextEntry (`id (0),
		// textentry label
		sformat(_("&Value of \"%1\" Attribute"), attr), value[0]:""));
	}
	else
	{
	    ret = add (ret, `TextEntry (`id (0),
		// textentry label
		sformat(_("&Values of \"%1\" Attribute"), attr), value[0]:""));
	    integer i = 1;
	    while (i < value_size)
	    {
		ret = add (ret, `TextEntry (`id (i), "", value[i]:""));
		if (size (value[i]:"" + 10) > hsize)
		    hsize = size (value[i]:"") + 10;
		i = i + 1;
	    }
	}
	return ret;
    }

    term values = generate_value_list ();
    // button label
    term add_button = `PushButton(`id(`new), `opt (`key_F3), _("&Add Value"));

    if (size (offer) > 0 || browse)
    {
	// menubutton item (default value)
	list mb = [ `item(`id(`new), _("&Empty Entry")) ];
	if (browse)
	    mb	= add (mb, `item(`id(`browse), _("Bro&wse")));
	foreach (string it, (list<string>) offer, ``{
	    mb = add (mb, `item(`id(it), it));
	});
	// button label
	add_button = `MenuButton(`id(`mb), `opt (`key_F3), _("&Add Value"), mb);
    }

    UI::OpenDialog( `opt(`decorated), `HBox(
	`HSpacing(1),
	`VBox(
	    `HSpacing (hsize > 50 ? hsize : 50),
	    `ReplacePoint (`id(`rp), values),
	    `HBox(
		`PushButton(`id(`ok),`opt(`default,`key_F10),Label::OKButton()),
		`PushButton(`id(`cancel),`opt (`key_F9), Label::CancelButton()),
		`PushButton(`id(`help),`opt (`key_F2), Label::HelpButton()),
		(single)? `Empty() :
		add_button
	    )
	),
	`HSpacing(1)
    ));
    any result = nil;
    list<string> new_value = [];

    if (value_size == 0)
	value_size = 1;
    UI::SetFocus (`id(value_size-1));
    while (true)
    {
	result = UI::UserInput ();
	if (result == `cancel)
	{
	    new_value = org_value;
	    break;
	}
	if ( result == `help )
	{
	    Wizard::ShowHelp( help_text );
	}
	if (result == `new || contains (offer, result) || result == `browse)
	{
	    integer j = 0;
	    value = [];
	    while (j < value_size)
	    {
		value = add (value, (string) UI::QueryWidget (`id(j), `Value) );
		j = j + 1;
	    }
	    if (contains (offer, result) && value[value_size-1]:"" == "")
	    {
		// relace last empty entry
		value [value_size-1] = (string) result;
	    }
	    else if (result == `browse)
	    {
		value [value_size-1] = BrowseTree ("");
	    }
	    else
	    {
		// add new entry
		value = add (value, (result == `new)? "" : (string) result);
		value_size = value_size + 1;
	    }
	    UI::ReplaceWidget (`id(`rp), generate_value_list ());
	    UI::SetFocus (`id(value_size-1));
	}
	if (result == `ok)
	{
	    integer j = 0;
	    boolean duplicate = false;
	    new_value = [];
	    while (j < value_size && !duplicate)
	    {
		string v = (string) UI::QueryWidget (`id(j), `Value);
		if (!contains (org_value, v) && contains (conflicts, v))
		{
		    //error popup
		    Popup::Error (sformat (_("The value \'%1\' already exists.
Please select another one."), v));
		    duplicate = true;
		}
		if (v != "") new_value = add (new_value, v);
		j = j + 1;
	    }
	    if (duplicate) continue;
	    break;
	}
    }
    UI::CloseDialog();
    return new_value;
}

/**
 * Popup for adding new configuration module
 * @param conflicts list of forbidden names ('cn' values)
 * @param available list of possible object classes for new module
 * @return map of new module (contains its name and object class)
 */
global define map NewModule (list available, list conflicts) ``{

    map descriptions = $[
	// description of configuration object
	"suseuserconfiguration": _("Configuration of user management tools"),
	// description of configuration object
	"susegroupconfiguration": _("Configuration of group management tools"),
    ];
    // label
    term r_buttons = `VBox( `Left(`Label (_("Object Class of New Module"))));
    foreach (string class, (list<string>) available, ``{
	string desc = class;
	if (descriptions [class]:"" != "")
	    desc = sformat ("%1 (%2)", class, descriptions [class]:"");
	r_buttons = add (r_buttons,`Left(`RadioButton (`id(class), desc,true)));
    });
    UI::OpenDialog( `opt(`decorated), `HBox(
	`HSpacing(1),
	`VBox(
	    `HSpacing (50),
	    `RadioButtonGroup (`id(`rb), r_buttons),
	    // textentry label, do not translate "cn"
	    `TextEntry (`id (`cn), _("&Name of New Module (\"cn\" value)")),
	    `HBox(
		`PushButton(`id(`ok),`opt(`default,`key_F10),Label::OKButton()),
		`PushButton(`id(`cancel),`opt (`key_F9), Label::CancelButton())
	    )
	),
	`HSpacing(1)
    ));
    any result = nil;
    string new_value = "";
    string class = "";

    UI::SetFocus (`id(`cn));
    while (true)
    {
	result = UI::UserInput ();
	if (result == `cancel)
	{
	    new_value = "";
	    break;
	}
	if (result == `ok)
	{
	    new_value = (string) UI::QueryWidget (`id(`cn), `Value);
	    if (contains (conflicts, new_value))
	    {
		//error popup
		Popup::Error (_("The entered value already exists.
Select another one.
"));
		continue;
	    }
	    if (new_value == "")
	    {
		//error popup
		Popup::Error (_("Enter the module name."));
		continue;
	    }
	    class = (string) UI::QueryWidget (`id(`rb), `CurrentButton);
	    break;
	}
    }
    UI::CloseDialog();
    return $[ "class": class, "cn": new_value ];
}

/**
 * Popup for adding new default value (default value is template's attribute)
 * @param conflicts list of attributes already set
 * @param available list of possible attributes
 * @return map of new "default value" (contains attribute name and value)
 */
global define map AddDefaultValue (list available, list conflicts) ``{

    // help text 1/3
    string help_text = _("<p>Here, set the values of attributes belonging
to an object using the current template. Such values are used as defaults when
the new object is created.</p>
") +

    /*
    // help text 2/3 do not translate "defaultObjectClass"
    _("<p>The list of attributes provided in <b>Attribute Name</b> is the
list of allowed attributes for objects described in the \"defaultObjectClass\"
entry of the current template.</p>
") +
    */

    // help text 3/3 do not translate "homedirectory"
    _("<p>You can use special syntax to create attribute
values from existing ones. The expression <i>%attr_name</i> will be replaced
with the value of attribute \"attr_name\" (for example, use \"/home/%uid\"
as a value of \"homeDirectory\").</p>
");

    available = filter (string attr, (list<string>) available, ``(!contains (conflicts,attr)));

    UI::OpenDialog( `opt(`decorated), `HBox(
	`HSpacing(1),
	`VBox(
	    `HSpacing (50),
	    `VSpacing(0.5),
	    // combobox label
	    `Left(`ComboBox (`id (`attr),`opt(`editable), _("Attribute &Name"),
		available)),
	    `VSpacing(0.5),
	    // textentry label
	    `TextEntry (`id (`val), _("Attribute &Value")),
	    `VSpacing(0.5),
	    `HBox(
		`PushButton(`id(`ok),`opt(`default,`key_F10),Label::OKButton()),
		`PushButton(`id(`cancel), `opt(`key_F9), Label::CancelButton()),
		`PushButton(`id(`help),`opt (`key_F2), Label::HelpButton())
	    ),
	    `VSpacing(0.5)),
	`HSpacing(1)
    ));
    any result = nil;
    string new_value = "";
    string attr = "";

    UI::SetFocus (`id(`attr));
    while (true)
    {
	result = UI::UserInput ();
	if (result == `cancel)
	{
	    new_value = "";
	    break;
	}
	if ( result == `help )
	{
	    Wizard::ShowHelp( help_text );
	}
	if (result == `ok)
	{
	    attr	= (string) UI::QueryWidget (`id(`attr), `Value);
	    new_value	= (string) UI::QueryWidget (`id(`val), `Value);
	    break;
	}
    }
    UI::CloseDialog();
    return $[ "attr": attr, "value": new_value ];
}

/**
 * dialog for Password Policy configuration object
 * @param ppolicy data with Password Policy object to be edited (as obtained from LDAP search)
 * @return map with modifications of ppolicy object
 */
global define map<string,any> PasswordPolicyDialog (map<string,any> ppolicy) {

    // reduce the list values to single ones
    ppolicy	= mapmap (string a, any val, ppolicy, {
	if (is (val, list) && Ldap::SingleValued (a))
	    val	= ((list)val)[0]:nil;
	if (val == "TRUE" || val == "FALSE")
	    val	= (val == "TRUE");
	return $[ a: val ];
    });
    map<string,any> ppolicy_orig	= ppolicy;

    // help text for Password Policy Dialog
    string help_text = _("<p>Select from <b>Password Change Policies</b>, <b>Password Aging Policies</b> and <b>Lockout Policies</b> tabs to choose LDAP Password Policy groups of attributes to configure.</p>");


    // tab-specific help texts
    map tabs_help_text	= $[
	// help text for pwdInHistory attribute
	`pwchange	: _("<p>Specify the maximum number of used passwords stored in history by adjusting <b>Maximum number of passwords stored<b>.</p>") +

	// help text for pwdMustChange attribute
	_("<p>Check <b>User Must Change Password After Reset</b> to force users change password after the password is reset or changed by administrator.</p>") +

	// help text for pwdAllowUserChange attribute
	_("<p>Check <b>User Can Change Password</b> to allow users changing their passwords.</p>") +

	// help text for pwdSafeModify attribute
	_("<p>If existing password must be provided along with the new password when being changed, check <b>Old Password Required for Password Change</b>.</p>") +

	// help text for pwdCheckQuality attribute
	_("<p>Select how the password quality should be verified while being modified or added. Quality checking might not be enforced at all. With second option, server checks the quality, but accepts the password if it is unable to check it. Last option means that server will check the password quality, and if the server is unable to verify it, it will refuse the password.<p>") +

	// help text for pwdMinLength attribute
	_("Set the minimum number of characters that must be used in a password in <b>Minimum Password Length</b> entry.</p>"),

	// help text for pwdMinAge attribute
	`aging		: _("<p><b>Minimal Password Age</b> holds the number of seconds that must elapse between  modifications to the password.</p>") +

	// help text for pwdMaxAge attribute
	_("<p><b>Maximal Password Age</b> holds the number of seconds after which a modified password will expire.</p>") +

	// help text for pwdExpireWarning attribute
	_("<p>In <b>Seconds before Password Expiration to Issue Warning</b> specify the maximum number of seconds before a password is due to expire that expiration warning messages will be returned to an authenticating user.</p>") +

	// help text for pwdGraceAuthNLimit attribute
	_("<p>Set the number of times an expired password can be used to authenticate in <b>Possible Usages of Expired Password</b>.</p>"),

	// help text for pwdLockout attribute
	`lockout	: _("<p>Check <b>Enable Password Locking</b> to disallow usage of password after a specified number of consecutive failed bind attempts.</p>") +

	// help text for pwdMaxFailure attribute
	_("<p>Set the number of consecutive failed bind  attempts after which the password may not be used to authenticate in <b>Bind Failures to Lock the Password</b>.</p>") +

	// help text for pwdLockoutDuration attribute
	_("<p>Set the number of seconds that the password cannot be used in <b>Password Lock Duration</b>.</p>") +

	// help text for pwdFailureCountInterval attribute
	_("<p><b>Bind Failures Cache Duration</b> holds the number of seconds after which the password failures are purged from the failure counter, even though no successful authentication occurred.</p>"),
    ];

    // map of attribute names for each tab
    map attributes	= $[
	`pwchange	: [ "pwdinhistory", "pwdmustchange", "pwdallowuserchange", "pwdsafemodify",
	    "pwdcheckquality", "pwdminlength" ],
	`aging		: [ "pwdminage", "pwdmaxage", "pwdexpirewarning", "pwdgraceauthnlimit" ],
	`lockout	: [ "pwdlockout", "pwdlockoutduration", "pwdmaxfailure",
	    "pwdfailurecountinterval"],
    ];
    map default_values	= $[
	"pwdmustchange"		: false,
	"pwdallowuserchange"	: true,
	"pwdsafemodify"		: false,
	"pwdlockout"		: false,
    ];

    // maximal value of IntFields
    integer max		= 99999;

    list<term> tabs	= [
	// tab label
	`item(`id(`pwchange), _("&Password Change Policies"), true),
	// tab label
	`item(`id(`aging), _("Pa&ssword Aging Policies")),
	// tab label
	`item(`id(`lockout), _("&Lockout Policies")),
    ];
    term tabs_term = `VBox (
	`DumbTab (`id(`tabs), tabs,
	    `ReplacePoint(`id(`tabContents ), `VBox (`HVStretch())))
    );
    boolean has_tabs	= true;
    if (!UI::HasSpecialWidget (`DumbTab))
    {
	has_tabs	= false;
	term tabbar	= `HBox ();
	foreach (term it, tabs, {
	    string label = it[1]:"";
	    tabbar = add (tabbar,`PushButton (it[0]:`id(label), label));
	});
	tabs_term = `VBox (`Left(tabbar),
	    `Frame ("", `ReplacePoint(`id(`tabContents), `HVStretch()))
	);
    }

    term contents = `VBox(
	`Label (ppolicy["dn"]:""),
        `VSpacing (0.5),
	tabs_term
    );

    // generate the term of password policy tab and update the help text
    void set_password_policies_term () {
	integer	pwdcheckquality	= tointeger (ppolicy["pwdcheckquality"]:"0");
	term tab_cont	= `Top (`HBox (`HSpacing (0.5), `VBox (
	    `VSpacing (0.8),
	    // IntField label
	    `IntField (`id ("pwdinhistory"), _("Ma&ximum Number of Passwords Stored"),
		0, max, tointeger (ppolicy["pwdinhistory"]:"0")),
	    `VSpacing (0.5),
	    // checkbox label
	    `Left (`CheckBox (`id ("pwdmustchange"), _("U&ser Must Change Password After Reset"),
		ppolicy["pwdmustchange"]:false)),
	    `VSpacing (0.2),
	    // checkbox label
	    `Left (`CheckBox (`id ("pwdallowuserchange"), _("&User Can Change Password"),
		ppolicy["pwdallowuserchange"]:true)),
	    `VSpacing (0.2),
	    // checkbox label
	    `Left (`CheckBox (`id ("pwdsafemodify"), _("&Old Password Required for Password Change"),
		ppolicy["pwdsafemodify"]:false)),
	    `VSpacing (0.5),
	    `HBox (`HSpacing (2), `Frame (_("Password Quality Checking"), `VBox (
		`VSpacing (0.5),
		`RadioButtonGroup (`id("pwdcheckquality"), `VBox (
		    `Left (`RadioButton (`id(0), `opt (`notify),
			_("&No checking"), pwdcheckquality == 0)),
		    `Left (`RadioButton(`id(1), `opt (`notify),
			_("Acc&ept passwords unable to check"), pwdcheckquality == 1)),
		    `Left (`RadioButton(`id(2), `opt (`notify),
			_("&Refuse passwords unable to check"), pwdcheckquality == 2))
		)),
		`VSpacing (0.5),
		// IntField label
		`IntField (`id ("pwdminlength"), _("&Minimum Password Length"), 0, max,
		    tointeger (ppolicy["pwdminlength"]:"0"))
	    )))
	), `HSpacing (0.5)));

	UI::ReplaceWidget (`tabContents, tab_cont);
	UI::ChangeWidget (`id ("pwdminlength"), `Enabled, pwdcheckquality > 0);
	return;
    }

    // generate the term of password aging tab
    void set_aging_policies_term () {

	term tab_cont = `Top (`HBox (`HSpacing (0.5), `VBox (
	    `VSpacing (0.8),
	    // IntField label
	    `IntField (`id ("pwdminage"), _("Minimal Password Age (seconds)"), 0, max, 0),
	    // IntField label
	    `IntField (`id ("pwdmaxage"), _("Maximal Password Age (seconds)"), 0, max, 0),
	    // IntField label
	    `IntField (`id ("pwdexpirewarning"),
		_("Seconds before Password Expiration to Issue Warning"), 0, max, 0),
	    `IntField (`id ("pwdgraceauthnlimit"),
		// IntField label
		_("Possible Usages of Expired Password"), 0, max, 0)
	), `HSpacing (0.5)));
	UI::ReplaceWidget (`tabContents, tab_cont);
	foreach (string attr, attributes[`aging]:[], {
	    UI::ChangeWidget (`id (attr), `Value, tointeger (ppolicy[attr]:"0"));
	});
	return;
    }

    // generate the term of lockout aging tab
    void set_lockout_policies_term () {

	boolean pwdlockout	= ppolicy["pwdlockout"]:false;

	term tab_cont = `Top (`HBox (`HSpacing (0.5), `VBox (
	    `VSpacing (0.8),
	    // check box label
	    `Left (`CheckBox (`id ("pwdlockout"), `opt (`notify), _("Enable Password Locking"),
		pwdlockout)),
	    `VSpacing (0.5),
	    // intField label
	    `IntField (`id ("pwdmaxfailure"), _("Bind Failures to Lock the Password"),
		0, max, 0),
	    `IntField (`id ("pwdlockoutduration"),
		// intField label
		_("Password Lock Duration"), 0, max, 0),
	    `IntField (`id ("pwdfailurecountinterval"),
		// intField label
		_("Bind Failures Cache Duration"), 0, max, 0)
	), `HSpacing (0.5)));

	UI::ReplaceWidget (`tabContents, tab_cont);
	foreach (string attr, [ "pwdlockoutduration", "pwdmaxfailure", "pwdfailurecountinterval"], {
	    UI::ChangeWidget (`id (attr), `Value, tointeger (ppolicy[attr]:"0"));
	    UI::ChangeWidget (`id (attr), `Enabled, pwdlockout);
	});
	return;
    }

    symbol current_tab	= `pwchange;
    any result		= nil;

    Wizard::OpenNextBackDialog ();

    // dialog label
    Wizard::SetContentsButtons (_("Password Policy Configuration"), contents,
	help_text + tabs_help_text[current_tab]:"", Label::CancelButton(), Label::AcceptButton());
    Wizard::HideAbortButton();

    set_password_policies_term ();

    while (true)
    {
	result		= UI::UserInput ();

	if (is(result,symbol) && contains ([`back, `cancel, `abort], (symbol)result))
	    break;

	// save the values from UI
	foreach (string attr, attributes[current_tab]:[], {
	    any val	= UI::QueryWidget (`id (attr), `Value);
	    if (is (val, integer))
		val	= sformat ("%1", val);
	    ppolicy[attr]	= val;
	});

	if ((result == `pwchange || result == `aging || result == `lockout) && result!= current_tab)
	{
	    if (result == `pwchange)
		set_password_policies_term ();
	    else if (result == `aging)
		set_aging_policies_term ();
	    else if (result == `lockout)
		set_lockout_policies_term ();
	    current_tab	= (symbol) result;
	    if (has_tabs)
		UI::ChangeWidget (`id (`tabs), `CurrentItem, current_tab);
	    Wizard::SetHelpText (help_text + tabs_help_text[current_tab]:"");
	    continue;
	}
	if (result == `next)
	{
	    boolean cont = false;

	    // check the template required attributes...
	    foreach (string oc, ppolicy["objectclass"]:[], ``{
		if (cont) return;
		foreach (string attr, Ldap::GetRequiredAttributes (oc), ``{
		    any val = ppolicy[attr]:nil;
		    if (!cont && val == nil || val == [] || val == "") {
			//error popup, %1 is attribute name
			Popup::Error (sformat (_("The \"%1\" attribute is mandatory.
Enter a value."), attr));
			UI::SetFocus (`id(`table));
			cont = true;
		    }
		});
	    });
	    if (cont) continue;
	    break;
	}
	// now solve events inside the tabs
	if (current_tab == `pwchange && is (result, integer))
	{
	    UI::ChangeWidget (`id ("pwdminlength"), `Enabled, result != 0);
	}
	if (current_tab == `lockout && result == "pwdlockout")
	{
	    boolean pwdlockout = (boolean) UI::QueryWidget (`id ("pwdlockout"), `Value);
	    foreach (string at, ["pwdlockoutduration", "pwdmaxfailure", "pwdfailurecountinterval"],
	    {
		UI::ChangeWidget (`id (at), `Enabled, pwdlockout);
	    });
	}
    }
    Wizard::CloseDialog ();

    map<string,any> ret	= $[];
    if (result == `next)
    {
	foreach (string key, any val, ppolicy, {
	    if (!haskey (ppolicy_orig, key) &&
		(val == default_values[key]:nil || val == "0"))
		return;
	    if (val != ppolicy_orig[key]:nil)
	    {
		if (is (val, boolean))
		    val	= (val == true) ? "TRUE" : "FALSE";
		ret[key]	= val;
	    }
	});
    }
    return ret;
}

}//EOF
