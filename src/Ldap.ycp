/**
 * File:	modules/Ldap.ycp
 * Module:	Configuration of LDAP client
 * Summary:	LDAP client configuration data, I/O functions.
 * Authors:	Thorsten Kukuk <kukuk@suse.de>
 *		Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{

    module "Ldap";
    textdomain "ldap-client";

    import "Runlevel";
    import "Report";
    import "Summary";
    import "Progress";
    import "Label";
    import "Popup";
    import "Mode";

    import "PamSettings";

    include "ldap/routines.ycp";

    /**
     * Write only, used during autoinstallation.
     * Don't run services and SuSEconfig, it's all done at one place.
     */
    global boolean write_only = false;

    /**
     * Should ypbind be started at boot?
     * If not, other settings are not touched.
     */
    global boolean start = false;

    /**
     * IP addresses of LDAP server.
     */
    global string  server = "";

    // local settings modified?
    global boolean modified = false;

    // base DN
    string domain = "";
    string old_domain = nil;
    boolean domain_changed = false;

    /* Do we have an v2 or v3 ldap server? */
    global boolean ldap_v2 = false;
    global boolean ldap_tls = false;

    /* Which crypt method should be used? If not set, use crypt.
       Not configurable now! TODO */
    global string pam_password = "";

    global integer default_port = 389;

    /**
     * If home directories of LDAP users are stored on this machine
     */
    global boolean file_server = false;

    // settings from ldap.conf
    global string nss_base_passwd = "";
    global string nss_base_shadow = "";
    global string nss_base_group = "";
    // settings from LDAP configuration objects
    global string user_base = "";
    global string group_base = "";

    /* stored values of /etc/nsswitch.conf */
    map nsswitch = $[ "passwd" : [], "group": []];

    // are we binding anonymously?
    global boolean anonymous = false;

    // bind password for LDAP server
    global string bind_pass = nil;

    /**
     * DN for binding to LDAP server
     */
    global string bind_dn = "";

    // DN of currently edited configuration module
    global string current_module_dn = "";
    // DN of currently edited template
    global string current_template_dn = "";

    /**
     * DN of base configuration object
     */
    global string base_config_dn = "";

    /**
     * defaults for adding new config objects and templates
     */
    global map new_objects = $[
	"userConfiguration"	: $[
	    "searchFilter"		: ["objectClass=posixAccount"],
	    "passwordHash"	: ["crypt"],
	    "skelDir"		: ["/etc/skel"],
	    "minUniqueId"	: ["500"],
	    "maxUniqueId"	: ["60000"],
	    "minPasswordLength" : ["5"],
	    "maxPasswordLength" : ["8"],
	],
	"groupConfiguration"	: $[
	    "searchFilter"	: ["objectClass=posixGroup"],
	    "minUniqueId"	: ["500"],
	    "maxUniqueId"	: ["60000"],
	],
	"userTemplate"		: $[
	    "objectClass"	: [ "top", "objectTemplate", "userTemplate"],
	    "namingAttribute"	: [ "uid" ],
	    "defaultObjectClass":
		[ "top", "posixAccount", "shadowAccount", "inetOrgPerson"],
	    "defaultValue"	: [ "gidNumber=100" ]
	],
	"groupTemplate"		: $[
	    "objectClass"	: [ "top", "objectTemplate", "groupTemplate"],
	    "namingAttribute"	: [ "cn" ],
	    "defaultObjectClass": [ "top", "posixGroup", "groupOfUniqueNames"]
	]
    ];

    global string base_template_dn = base_config_dn;

    // settings saved at LDAP server modified
    global boolean ldap_modified = false;

    global map config_modules = $[];
    global map templates = $[];

    global boolean binded = false;

    // DN's of groups (posixGroups) in LDAP
    global list groups_dn = [];

    /**
     * Map of object classes (from schema). Indexed by names.
     */
    global map object_classes = $[];
    //TODO create defaults when schema could not be reached...

    /**
     * Map of atribute types (from schema). Indexed by names.
     */
    global map attr_types = $[
    ];


    //----------------------------------------------------------------

    /**
     * If the domain has changed from a nonempty one, it may only be
     * changed at boot time. Use this to warn the user.
     * @return whether changed by SetDomain
     */
    global define boolean DomainChanged () ``{
	return domain_changed;
    }

    /**
     * @return Get the LDAP domain.
     */
    global define string GetDomain () ``{
	return domain;
    }

    /**
     * Set the LDAP domain.
     * @param new_domain a new domain
     */
    global define void SetDomain (string new_domain) ``{
	domain = new_domain;
	if (domain != old_domain && old_domain != "")
	{
	    domain_changed = true;
	}
    }

    /* ------------- auto_yast functions -------------------------------- */

    /**
     * Get all the LDAP configuration from a map.
     * When called by ldap_auto (preparing autoinstallation data)
     * the map may be empty.
     * @param settings	$["start": "domain": "servers":[...] ]
     * @return	success
     */
    global define boolean Import (map settings) ``{
	start = lookup (settings, "start_ldap", false);
	server = lookup (settings, "ldap_server", "");
	domain = lookup (settings, "ldap_domain", "");
	ldap_v2 = lookup (settings, "ldap_v2", false);
	ldap_tls = lookup (settings, "ldap_tls", false);
	pam_password = lookup (settings, "pam_password", "crypt");
	old_domain = domain;
	return true;
    }

    /**
     * Only set variables, without checking anything
     * @return: void
     */
    global define void Set(map settings)  ``{
	start = lookup (settings, "start_ldap", false);
	server = lookup (settings, "ldap_server", "");
	domain = lookup (settings, "ldap_domain", "");
	ldap_v2 = lookup (settings, "ldap_v2", false);
	ldap_tls = lookup (settings, "ldap_tls", false);
	pam_password = lookup (settings, "pam_password", "crypt");
	return;
    }

    /**
     * Dump the LDAP settings to a map, for autoinstallation use.
     * @return $["start":, "servers":[...], "domain":]
     */
    global define map Export () ``{
	return $[
	    "start_ldap": start,
	    "ldap_server": server,
	    "ldap_domain": domain,
	    "ldap_v2": ldap_v2,
	    "ldap_tls": ldap_tls,
	    "pam_password": pam_password,
	    ];
    }

    /**
     * Summary()
     * returns html formated configuration summary
     * @return summary
     */
    global define string Summary ()
	``{
	string summary = "";
	summary = Summary::AddHeader(summary, _("LDAP Client enabled"));
	summary = Summary::AddLine(summary, (start) ? "Yes" : Summary::NotConfigured());
	summary = Summary::AddHeader(summary, _("LDAP Domain"));
	summary = Summary::AddLine(summary, (domain != "") ? domain : Summary::NotConfigured());
	summary = Summary::AddHeader(summary, _("LDAP Server"));
	summary = Summary::AddLine(summary,( server!="") ? server : Summary::NotConfigured());
	summary = Summary::AddHeader(summary, _("LDAP Version 2"));
	summary = Summary::AddLine(summary, (ldap_v2) ? "Yes" : Summary::NotConfigured());
	summary = Summary::AddHeader(summary, _("LDAP &TLS/SSL"));
	summary = Summary::AddLine(summary, (ldap_tls) ? "Yes" : Summary::NotConfigured());

	return summary;
    }

    /**
     * returns html formated configuration summary (shorter than Summary)
     * @return summary
     */
    global define string ShortSummary () ``{
	string nc = Summary::NotConfigured();
	string summary = "";
	// summary text
	summary = sformat (_("<b>Servers</b>:%1<br>"), server!=""? server: nc) +
	// summary text
	sformat (_("<b>Base DN</b>:%1<br>"), domain != "" ? domain : nc) +
	// summary text (yes/no follows)
	sformat (_("<b>Client Enabled</b>:%1<br>"), start ? _("Yes") : _("No"));
	return summary;
    }

    /* ------------- read/write functions ------------------------------- */

    /**
     * Read single entry from /etc/ldap.conf file
     * @param entry entry name
     * @param defvalue default value if entry is not present
     * @return entry value
     */
    define string ReadLdapConfEntry (string entry, string defvalue) ``{

	string ret = SCR::Read(add (.etc.ldap_conf, entry));
	if (ret == nil)
	    ret = defvalue;
	return ret;
    }

    /**
     * Reads LDAP settings from the SCR
     * @return success
     */
    global define boolean Read () ``{

	start = (SCR::Execute (.target.bash, "/usr/bin/grep '^passwd:.*ldap' /etc/nsswitch.conf") == 0);
	server = ReadLdapConfEntry ("host", "");
	domain  = ReadLdapConfEntry ("base", "");
	old_domain = domain;

	ldap_v2 = (ReadLdapConfEntry ("ldap_version", "3") == "2");
	ldap_tls = (ReadLdapConfEntry ("ssl", "no") == "start_tls");

        nss_base_passwd = ReadLdapConfEntry ("nss_base_passwd", "");
        nss_base_shadow = ReadLdapConfEntry ("nss_base_passwd", "");
        nss_base_group = ReadLdapConfEntry ("nss_base_group", "");

	pam_password = ReadLdapConfEntry ("pam_password", "crypt");

	nsswitch["passwd"] = splitstring
	    (SCR::Read(.etc.nsswitch_conf.passwd)," ");
	nsswitch["group"] = splitstring
	    (SCR::Read(.etc.nsswitch_conf.group), " ");

	// read sysconfig values
	base_config_dn = SCR::Read (.sysconfig.ldap.BASE_CONFIG_DN);

	file_server = (SCR::Read (.sysconfig.ldap.FILE_SERVER) == "yes");

	bind_dn = SCR::Read (.sysconfig.ldap.BIND_DN);
	if (bind_dn == nil || bind_dn == "")
	    bind_dn = ReadLdapConfEntry ("binddn", "");

	return true;
    }


    /**
     * Saves LDAP configuration.
     * @param abort block for abort check
     * @return symbol
     */
    global define symbol Write (block abort) ``{

	// progress caption
	string caption = _("Writing LDAP Configuration...");
	integer no_of_steps = 4;

	Progress::New (caption, " ", no_of_steps, [
	    // progress stage label
	    _("Stop services"),
	    // progress stage label
	    _("Update configuration files"),
	    // progress stage label
	    _("Start services"),
	    // progress stage label
	    _("Update configuration in LDAP directory"),
           ], [
	    // progress step label
	    _("Stopping services..."),
	    // progress step label
	    _("Updating configuration files..."),
	    // progress step label
	    _("Starting services..."),
	    // progress step label
	    _("Updating configuration in LDAP directory..."),
	    // final progress step label
	    _("Finished") ],
	    "" );

	// -------------------- stop services
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;

	boolean ypbind_running = false;

	if (!write_only)
	{
	    ypbind_running = (Runlevel::ServiceStatus ("ypbind") == 0);
		Runlevel::RunInitScript ("ypbind", "stop");
	} else if (write_only && Mode::autoinst ){
		// Read existing nsswitch in autoinstallation mode
        nsswitch["passwd"] = splitstring
           (SCR::Read(.etc.nsswitch_conf.passwd)," ");
        nsswitch["group"] = splitstring
           (SCR::Read(.etc.nsswitch_conf.group), " ");
	}
	map new_nsswitch = $[ "passwd":"", "group": ""];

	// -------------------- update config files
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;

	if (start) // ldap used
	{
	    // update ldap.conf
	    SCR::Write(.etc.ldap_conf.host, server);
	    SCR::Write(.etc.ldap_conf.base, domain);
	    if (ldap_v2)
		SCR::Write(.etc.ldap_conf.ldap_version, "2");
	    else
		SCR::Write(.etc.ldap_conf.ldap_version, "3");

	    if (ldap_tls)
		SCR::Write(.etc.ldap_conf.ssl, "start_tls");
	    else
		SCR::Write(.etc.ldap_conf.ssl, "no");

	    SCR::Write(.etc.ldap_conf.pam_password, pam_password);

	    // save the user and group bases (check the LDAP config before)
	    user_base = domain;
	    group_base = domain;
	    foreach (`dn, `mod, config_modules, ``{
		if (contains (mod["objectClass"]:[], "userConfiguration"))
		    user_base = mod["defaultBase",0]:domain;
		if (contains (mod["objectClass"]:[], "groupConfiguration"))
		    group_base = mod["defaultBase",0]:user_base;
	    });
	    SCR::Write(.etc.ldap_conf.nss_base_passwd,
		(nss_base_passwd != "")? nss_base_passwd : user_base);
	    SCR::Write(.etc.ldap_conf.nss_base_shadow,
		(nss_base_shadow != "")? nss_base_shadow : user_base);
	    SCR::Write(.etc.ldap_conf.nss_base_group,
		(nss_base_group != "")? nss_base_group : group_base);

	    // write the changes in ldap.conf now
	    SCR::Write(.etc.ldap_conf, nil);

	    // pam settigs
	    foreach (`type, [ "account", "auth", "password" ], ``{
		PamSettings::AddValue ("pam_unix2", type, "use_ldap");
	    });

	    // modify sources in /etc/nsswitch.conf
	    foreach (`entry, `value, nsswitch, ``{
		new_nsswitch [entry] = mergestring ( value, " " );
		if (!contains (value, "ldap"))
		    new_nsswitch [entry] = new_nsswitch [entry]:"" + " ldap";
	    });
	    SCR::Write(.etc.nsswitch_conf.passwd, new_nsswitch["passwd"]:"");
	    SCR::Write(.etc.nsswitch_conf.group, new_nsswitch["group"]:"");
	    SCR::Write(.etc.nsswitch_conf, nil);
	}
	else // ldap is not used
	{

	    foreach (`entry, `value, nsswitch, ``{
		new_nsswitch [entry] = mergestring (
		    filter (`v, value, ``(v != "ldap")), " ");
		// just to make sure that something remains...
		if (new_nsswitch [entry]:"" == "")
		    new_nsswitch [entry] = "files";
	    });

	    SCR::Write(.etc.nsswitch_conf.passwd, new_nsswitch["passwd"]:"");
	    SCR::Write(.etc.nsswitch_conf.group, new_nsswitch["group"]:"");
	    SCR::Write(.etc.nsswitch_conf, nil);

	    foreach (`type, [ "account", "auth", "password" ], ``{
		PamSettings::RemoveValue ("pam_unix2", type, "use_ldap");
	    });
	}

	// write sysconfig values
	SCR::Write (.sysconfig.ldap.FILE_SERVER, file_server? "yes": "no");

	SCR::Write (.sysconfig.ldap.BASE_CONFIG_DN, base_config_dn);

	SCR::Write (.sysconfig.ldap.BIND_DN, bind_dn);

	// -------------------- start services
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;

	if (Runlevel::ServiceStatus ("nscd") == 0 && !write_only)
	{
	    Runlevel::RunInitScript ("nscd", "restart");
	}

	if (ypbind_running)
	{
	    Runlevel::RunInitScript ("ypbind", "restart");
	}

	// -------------------- write settings to LDAP
	Progress::NextStage ();
	if (eval (abort))
	    return `abort;

	if (ldap_modified)
	{
	    WriteLDAP (config_modules);
	    WriteLDAP (templates);
	}

	// final stage
	Progress::NextStage ();

	return `next;
    }

    /* ------------- functions for work with LDAP tree contents ------------ */

    /**
     * Error popup for errors detected during LDAP operation
     * @param type error type: binding/reading/writing
     * @param detailed error message (from agent-ldap)
     */
    global define void LDAPErrorMessage (string type, string error) ``{

        map ldap_error = $[
	// error message:
	"initialize": _("
Server could be down or unreachable."),

	// error message:
	"missing_dn": _("
Value of DN is missing or invalid."),

	// error message:
	"at_not_found": _("\nAttribute type not found.
"),

	// error message:
	"oc_not_found": _("\nObject class not found.
"),
	];

        map error_type = $[
	    // error message, more specific description follows
	    "init": _("Connection to LDAP server cannot be established."),
	    // error message, more specific description follows
	    "bind": _("Problem with connecting to the LDAP server."),
	    // error message, more specific description follows
	    "read": _("Problem with reading data from the LDAP server."),
	    // error message, more specific description follows
	    "users": _("There was a problem with writing LDAP users."),
	    // error message, more specific description follows
	    "groups": _("There was a problem with writing LDAP groups."),
	    // error message, more specific description follows
	    "write": _("There was a problem with writing data to LDAP server."),
	    // error message, more specific description follows
	    "schema": _("Problem with reading schema from the LDAP server."),
	];

	if (error == nil) error = "YaST error?";

	UI::OpenDialog (`HBox(`HSpacing (0.5),
	    `VBox(
		`VSpacing (0.5),
		// label
		`Left(`Heading (Label::ErrorMsg())),
		// default error message
		`Label (error_type[type]:_("Unknown LDAP error")),
		`ReplacePoint (`id(`rp), `Empty()),
		`VSpacing (0.5),
		`Left(`CheckBox (`id(`details), `opt (`notify),
		    // checkbox label
		    _("&Show Details"), false)),
		`PushButton (`id(`ok), `opt(`key_F10,`default),
		    Label::OKButton())
	    ),
	    `HSpacing(0.5))
	);
	any ret = nil;
	if (error == "")
	    UI::ChangeWidget (`id(`details), `Enabled, false);
	do
	{
	    ret = UI::UserInput();
	    if (ret == `details)
	    {
		if (UI::QueryWidget (`id(`details), `Value))
		    UI::ReplaceWidget (`id(`rp), `VBox (
			`Label (ldap_error[error]:error)));
		else
		    UI::ReplaceWidget (`id(`rp), `Empty());
	    }
	}
	while (ret != `ok && ret != `cancel);
	UI::CloseDialog();
    }

    /**
     * Reads and returns error message from agent
     */
    global define string LDAPError () ``{

	map err_map = LDAPErrorMap ();
	return err_map["msg"]:"";
    }

    /**
     * Reads and returns error map (=message + code) from agent
     */
    global define map LDAPErrorMap () ``{

        return (SCR::Read(.ldap.error));
    }

    /**
     * Initializes LDAP agent
     */
    global define string LDAPInit () ``{

	// ODO what if we have more servers?
	string ret = "";
	map args = $[
	    "hostname":     GetFirstServer (server),
	    "port":         GetFirstPort (server),
	    "version":      ldap_v2 ? 2 : 3
	];
	if (!SCR::Execute (.ldap, args))
	    ret = LDAPError();
	return ret;
    }

    // this is a hack
    global define string GetFirstServer (string servers) ``{

	list l_servers = splitstring (servers, " ");
	string srv = l_servers[0]:"";
	return substring (srv, 0, find (srv, ":"));
    }

    // this is a hack
    global define string GetFirstPort (string servers) ``{

	list l_servers = splitstring (servers, " ");
	string srv = l_servers[0]:"";
	if (!issubstring (srv, ":"))
	    return default_port;
	string s_port = substring (srv, find (srv, ":") + 1);
	if (s_port == "")
	    return default_port;
	else return tointeger (s_port);
    }

    /**
     * Binds to LDAP server
     * @param pass password
     */
    global define string LDAPBind (string pass) ``{

        string ret = "";
	if (pass != nil)
	{
	    map args = $[];
	    if (!anonymous)
		args = $[ "bind_dn": bind_dn, "bind_pw": pass];
	    if (!SCR::Execute (.ldap.bind, args))
		ret = LDAPError();
	}
	return ret;
    }

    /**
     * Asks user for bind password to LDAP server
     * @param anonymous if anonymous access could be allowed
     * @return password
     */
    global define string GetLDAPPassword (boolean enable_anonymous) ``{

	UI::OpenDialog (`opt(`decorated),
        `VBox(
            `HSpacing(40),
            // password entering label
            `Password(`id(`pw), _("&Enter the Password for LDAP Server:")),
            `HBox(
              `PushButton (`id(`ok),`opt(`key_F10, `default),
		Label::OKButton()),
              // button label
	      `PushButton (`id(`anon), `opt(`key_F6), _("&Anonymous Access")),
              `PushButton (`id(`cancel),`opt(`key_F9), Label::CancelButton())
            ))
	);
	if (!enable_anonymous)
	    UI::ChangeWidget (`id(`anon), `Enabled, false);
	UI::SetFocus (`id(`pw));
	any ret = UI::UserInput();
	string pw = "";
	if (ret == `ok)
	{
	    pw = UI::QueryWidget(`id(`pw), `Value);
	    anonymous = false;
	}
	else if (ret == `cancel)
	    pw = nil;
	else anonymous = true;
	UI::CloseDialog();
	return pw;
    }

    /**
     * Asks for LDAP password and tries to bind with it
     * @return password entered, nil on cancel
     */
    global define string LDAPAskAndBind (boolean enable_anonymous) ``{

	string pw = GetLDAPPassword (enable_anonymous);
        if (pw != nil)
	{
	    string ldap_msg = LDAPBind (pw);
	    while (pw != nil && ldap_msg != "")
	    {
		LDAPErrorMessage ("bind", ldap_msg);
		pw = GetLDAPPassword (enable_anonymous);
		ldap_msg = LDAPBind (pw);
	    }
	}
	return pw;
    }

    /**
     * Check if attribute allowes only single or multiple value
     * @param attr attribute name
     * @return answer
     */
    global define boolean SingleValued (string attr) ``{

	if (!haskey (attr_types, attr))
	{
	    map attr_type = SCR::Read (.ldap.schema.at, $["name":attr]);
	    if (attr_type == nil)
		attr_type = $[];
	    if (attr == "cn")
		// well, cn is not "single value" according to schema, but...
		attr_type ["single"] = true;
	    attr_types [attr] = attr_type;
	}
	return attr_types [attr, "single"]:false;
    }

    /**
     * Gets the description of attribute (from schema)
     * @param attr attribute name
     * @return description
     */
    global define string AttributeDescription (string attr) ``{

	if (!haskey (attr_types, attr))
	{
	    map attr_type = SCR::Read (.ldap.schema.at, $["name":attr]);
	    if (attr_type == nil)
		attr_type = $[];
	    attr_types [attr] = attr_type;
	}
	return attr_types [attr, "desc"]:"";
    }

    /**
     * Returns allowed and required attributes of given object class
     * Read it from LDAP if it was not done yet.
     */
    global define list GetAllAttributes (string class) ``{

	if (!haskey (object_classes, class))
	{
	    map object_class = SCR::Read (.ldap.schema.oc, $["name":class]);
	    if (object_class == nil)
		object_class = $[];
	    object_class ["all"] = union (object_class["may"]:[],
		object_class["must"]:[]);
	    // read attributes of superior classes
	    foreach (`sup_oc, object_class["sup"]:[], ``{
		object_class ["all"] = union (object_class ["all"]:[],
		    GetAllAttributes (sup_oc));
	    });
	    object_classes [class] = object_class;
	}
	return object_classes [class, "all"]:[];
    }

    /**
     * Returns the list of all allowed and required attributes for each
     * object class, given in the list of object classes
     */
    global define list GetObjectAttributes (list classes) ``{

	list ret = [];
	foreach (`class, classes, ``{
	    ret = union (ret, GetAllAttributes (class));
	});
	return ret;
    }

    /**
     * For a given object, add all atributes this object is allowed to have
     * according to its "objectClass" value. Added attributes have empty values.
     */
    global define map AddMissingAttributes (map object) ``{

	foreach (`class, object["objectClass"]:[], ``{
	    foreach (`attr, GetAllAttributes (class), ``{
		if (!haskey (object, attr))
		    object = add (object, attr, []);
	    });
	});
	return object;
    }

    /**
     * Prepare agent for later schema queries
     * (agent reads schema to its internal structures)
     */
    global define boolean InitSchema () ``{

	list schemas = SCR::Read (.ldap.search, $[
	    "base_dn":  "",
	    "attrs":    [ "subschemaSubentry" ],
	    "scope":    0, //0:base
	]);
	string schema_dn = schemas[0,"subschemaSubentry",0]:nil;
	if (schemas == nil || schema_dn == nil)
	{
	    LDAPErrorMessage ("schema", LDAPError());
	    return false;
	}
	boolean ok = SCR::Execute (.ldap.schema, $[ "schema_dn": schema_dn ]);

	if (!ok)
	    LDAPErrorMessage ("schema", LDAPError());
	return ok;
    }

    /**
     * In template object, convert the list of values
     * (in the form [ "a1=v1", "a2=v2"])
     * to map (in the form $[ "a1":"v1", "a2":"v2"]
     */
    global define map ConvertDefaultValues (map templ) ``{

        map template = add (templ, "default_values", $[]);
	foreach (`value, templ["defaultValue"]:[], ``{
	    string at = select (splitstring (value, "="), 0, "");
	    string v = substring (value, find (value, "=") + 1);
	    template ["default_values", at] = v;
	});
	return template;
    }

    /**
     * Read object templates from LDAP server
     */
    global define map ReadTemplates () ``{

	templates = $[];
	map all = SCR::Read (.ldap.search, $[
	    "base_dn":	base_config_dn,
	    "filter":   "objectClass=objectTemplate",
	    "attrs":	[],
	    "scope":	2,// sub: all templates under config DN
	    "map":	true,
	    "not_found_ok":	true,
	]);
	if (all == nil)
	{
	    LDAPErrorMessage ("read", LDAPError());
	    all = $[];
	}
	// create a helper map of default values inside ...
	templates = mapmap (`dn, `templ, all, ``{
	    map template = ConvertDefaultValues (templ);
	    template = AddMissingAttributes (template);
	    return [dn, template];
	});
	return templates;
    }

    /**
     * Read configuration moduels from LDAP server
     */
    global define map ReadConfigModules () ``{

	config_modules = $[];
	map modules = SCR::Read (.ldap.search, $[
	    "base_dn":	base_config_dn,
	    "filter":   "objectClass=moduleConfiguration",
	    "attrs":	[],
	    "scope":	1, // one - deeper searches would have problems with
			   // constructing the dn
	    "map":	true,
	    "not_found_ok":	true,
	]);
	if (modules == nil)
	{
	    LDAPErrorMessage ("read", LDAPError());
	    modules = $[];
	}
	config_modules = mapmap (`dn, `mod, modules, ``{
	    return [dn, AddMissingAttributes (mod)];
	});

	return config_modules;
    }

    /**
     * Search for one entry (=base scope) in LDAP directory
     * @param dn DN of entry
     * @return map with entry values, empty map if nothing found, nil on error
     */
    global define map GetLDAPEntry (string dn) ``{

	list objects = SCR::Read (.ldap.search, $[
	    "base_dn":	dn,
	    "attrs":	[],
	    "scope":	0, // only this one
	    "not_found_ok": true
	]);
	if (objects == nil)
	{
	    LDAPErrorMessage ("read", LDAPError());
	    return nil;
	}
	return objects[0]:$[];
    }

    /**
     * Check for existence of parent object of given DN in LDAP tree
     */
    global define boolean ParentExists (string dn) ``{

	string parent = substring (dn, find (dn,",")+1);
	map object = GetLDAPEntry (parent);
	if (object == nil)
	    return false;
	if (object == $[])
	{
	    // error message, %1 is DN
	    Popup::Error (sformat (_("A direct parent for DN '%1' 
does not exist in the LDAP directory.
The object with the selected DN cannot be created.
"), dn));
	    return false;
	}
	return true;
    }

    /**
     * Check if base config DN belongs to some existing object and offer
     * creating it if necessary
     */
    global define boolean CheckBaseConfig (string dn) ``{

	map object = GetLDAPEntry (dn);
	if (object == nil)
	{
	    return false;
	}
	if (object == $[])
	{
	    // yes/no popup, %1 is value of DN
	    if (Popup::YesNo (sformat (_("No entry with DN '%1'
exists on the LDAP server. Create it now?
"), dn)))
	    {
		if (!ParentExists (dn))
		    return false;
		return WriteLDAP ( $[ dn : $[
		    "objectClass"	: [ "top", "organizationalUnit"],
		    "modified"		: "added",
		    "ou"		: get_cn (dn)]]
		);
	    }
	    return false;
	}
	return true;
    }

    /**
     * Return main configuration object DN
     */
    global define string GetMainConfigDN () ``{

	return base_config_dn;
    }

    global define map GetConfigModules () ``{

	return eval (config_modules);
    }

    global define map GetTemplates () ``{

	return eval (templates);
    }

    /**
     * Creates default new map for a new object template
     * @param cn cn of new template
     * @param classes object classes of the object the template will belong to
     * @return template map
     */
    global define map CreateTemplate (string cn, list classes) ``{

	map obj = $[
	    "cn":		[ cn ],
	    "modified":		"added"
	];
	if (contains (classes, "userConfiguration"))
	{
	    obj = union (obj, new_objects ["userTemplate"]:$[]);
	}
	else if (contains (classes, "groupConfiguration"))
	{
	    obj = union (obj, new_objects ["groupTemplate"]:$[]);
	}
	else
	    obj["objectClass"] = [ "top", "objectTemplate"];

	obj = ConvertDefaultValues (obj);
	return AddMissingAttributes (obj);
    }

    /**
     * Creates default new map for new configuration object
     * @param class additional objectClass of new module (e.g.userConfiguration)
     */
    global define map CreateModule (string cn, string class) ``{

	map obj = $[
	    "cn":		[ cn ],
	    "objectClass":	add ([ "top", "moduleConfiguration"], class),
	    "modified":		"added"
	];
	// create some good defaults
	obj = union (obj, new_objects [class]:$[]);
	list templs = [];
	string templ_cn = "";
	string default_base = "";
	if (class == "userConfiguration")
	{
	    foreach (`dn, `t, templates, ``{
		if (contains (t["objectClass"]:[], "userTemplate"))
		    templs = add (templs, dn);
	    });
	    if (templs == [])
		templ_cn = "userTemplate";
	    default_base = nss_base_passwd;
	}
	if (class == "groupConfiguration")
	{
	    foreach (`dn, `t, templates, ``{
		if (contains (t["objectClass"]:[], "groupTemplate"))
		    templs = add (templs, dn);
	    });
	    if (templs == [])
		templ_cn = "groupTemplate";
	    default_base = nss_base_group;
	}
	// create proposal for defaultTemplate DN
	if (templ_cn != "")
	{
	    string tdn = sformat ("cn=%1,%2", templ_cn, base_config_dn);
	    integer i = 0;
	    while (GetLDAPEntry (tdn) != $[])
	    {
		tdn = sformat ("cn=%1%2,%3", templ_cn, i, base_config_dn);
		i = i + 1;
	    }
	    templs = [ tdn ];
	}
	obj ["defaultTemplate"] = templs;
	// create proposal for defaultBase DN
	if (default_base == "" || GetLDAPEntry (default_base) == $[])
	{
	    default_base = sformat ("ou=people,%1", domain);
	    if (GetLDAPEntry (default_base) == $[])
		default_base = domain;
	}
	obj ["defaultBase"] = [ default_base ];
	return AddMissingAttributes (obj);
    }

    /**
     * Returns DN's of groups (objectClass=posixGroup) in given base
     */
    global define list GetGroupsDN (string base) ``{

	if (groups_dn == [])
	    groups_dn = ReadDN (base, "objectClass=posixGroup");
	return groups_dn;
    }

    /**
     * Searches for DN's of all objects defined by filter in given base ("sub")
     * @param base search base
     * @param search_filter if filter is empty, "objectClass=*" is used
     */
    global define list ReadDN (string base, string search_filter) ``{

	list all = SCR::Read (.ldap.search, $[
	    "base_dn":	base,
	    "filter":   search_filter,
	    "attrs":	["cn"], // not necessary, just not read all values
	    "attrsOnly":true,
	    "scope":	2,
	    "dn_only":	true,
	]);
	if (all == nil)
	{
	    LDAPErrorMessage ("read", LDAPError());
	    return [];
	}
	return all;
    }

    /**
     * Check if given DN exist and if it points to some template
     * @return empty map if DN don't exist, template map if DN points
     *  to template object, nil if object with given DN is not template
     */
    global define map CheckTemplateDN (string dn) ``{

	map object = GetLDAPEntry (dn);
	if (object == nil)
	    return nil;
	if (object == $[])
	{
	    // OK, does not exist
	    return $[];
	}
	else if (contains (object ["objectClass"]:[], "objectTemplate"))
	{
	    // exists as a template -> return object
	    object = ConvertDefaultValues (object);
	    object ["modified"] = "edited";
	    return AddMissingAttributes (object);
	}
	else
	{
	    // error message
	    Popup::Error (_("Object with selected DN exists, but it is not a template object.
Select another one.
"));
	    return nil;
	}
    }

    /**
     * Save the edited map of configuration modules to global map
     */
    global define boolean CommitConfigModules (map modules) ``{

	foreach (`dn, `modmap, modules, ``{

	    if (!haskey (config_modules, dn))
	    {
		config_modules [dn] = eval (modmap);
		ldap_modified = true;
		return;
	    }
	    foreach (`attr, `val, modmap, ``{
		if (config_modules [dn, attr]:"" != val)
		{
		    config_modules [dn, attr] = val;
		    if (!haskey (modmap, "modified"))
			config_modules [dn, "modified"] = "edited";
		    ldap_modified = true;
		    y2debug ("modified value: %1", val);
		}
	    });
	});
	return true;
    }

    /**
     * Save the edited map of templates to global map
     */
    global define boolean CommitTemplates (map templs) ``{

	foreach (`dn, `template, templs, ``{

	    if (!haskey (templates, dn))
	    {
		// dn changed
		templates [dn] = eval (template);
		ldap_modified = true;
		return;
	    }
	    foreach (`attr, `val, template, ``{
		if (templates [dn, attr]:"" != val)
		{
		    templates [dn, attr] = val;
		    if (!haskey (template, "modified"))
			templates [dn, "modified"] = "edited";
		    ldap_modified = true;
		    y2debug ("modified value: %1", val);
		}
	    });
	});
	return true;
    }

    /**
     * Writes map of objects to LDAP
     * @param objects map of objects to write. It is in the form:
     * $[ DN: (map) attribute_values]
     * @example TODO
     * @return error map (empty on success)
     */
    global define map WriteToLDAP (map objects) ``{

	map ret = $[];
	foreach (`dn, `object, objects, ``{

	    if (ret != $[])
		return;
	    string action = object["modified"]:"";
	    if (action != "")
		object = remove (object, "modified");
	    else return;

	    if (haskey (object, "default_values"))
	    {
		object["defaultValue"] = maplist (`key, `val, object["default_values"]:$[], ``{
		    return sformat ("%1=%2", key, val);
		});
		object = remove (object, "default_values");
	    }
	    if (action == "added")
	    {
		if (!SCR::Write (.ldap.add, $[ "dn": dn ], object))
		    ret = LDAPErrorMap();
	    }
	    if (action == "edited")
	    {
		if (!SCR::Write (.ldap.modify, $[
		    "dn":		dn,
		    "check_attrs":	true ], object))
		    ret = LDAPErrorMap();
	    }
	    if (action == "renamed")
	    {
		string rdn = select (splitstring (dn, ","), 0, "");
		dn = object["old_dn"]:dn;
		object = remove (object, "old_dn");
		if (!SCR::Write (.ldap.modify, $[
			"dn":	dn,// the original DN
			"rdn":	rdn,
			"deleteOldRDN":	true,
			"check_attrs":	true ], object))
		    ret = LDAPErrorMap();
	    }
	    if (action == "deleted")
	    {
		if (object ["old_dn"]:dn != dn)
		    dn = object ["old_dn"]:dn;
		if (!SCR::Write (.ldap.delete, $[ "dn":	dn ]))
		    ret = LDAPErrorMap();
	    }
	});
	return ret;
    }

    /**
     * Writes map of objects to LDAP. Ask for password, when needed and
     * shows the error message when necessary.
     * @return success
     */
    global define boolean WriteLDAP (map objects) ``{

	map error = $[];
	if (anonymous || bind_pass == nil)
	{
	    bind_pass = LDAPAskAndBind (false);
	}
	// nil means "canceled"
	if (bind_pass != nil)
	{
	    error = WriteToLDAP (objects);
	    if (error != $[])
		LDAPErrorMessage ("write", error["msg"]:"");
	}
	return error == $[];
    }
}
